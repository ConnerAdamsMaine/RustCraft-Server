Proposed Solution Path
Here's what I recommend we fix in order:
Priority 1 - Fix NBT Endianness:
Replace all put_i16, put_i32, put_f32 with big-endian equivalents:
rustbytes.put_i16(0);  // WRONG
bytes.put_i16_be(0); // CORRECT
Priority 2 - Verify String Length Encoding:
Ensure string lengths in NBT are big-endian i16:
rustbytes.put_i16_be(message_id.len() as i16); // Instead of manual slicing
Priority 3 - Add Registry Data Validation:
Before sending, let's add a validation pass that checks for null bytes:
rustfn validate_identifier(id: &str) -> Result<()> {
    if id.contains('\0') {
        return Err(anyhow!("Identifier contains null byte: {:?}", id));
    }
    if !id.chars().all(|c| c.is_ascii_alphanumeric() || matches!(c, '/' | '.' | '_' | '-' | ':')) {
        return Err(anyhow!("Invalid identifier characters: {}", id));
    }
    Ok(())
}
Priority 4 - Simplify Registry Approach:
Instead of manually building NBT, consider loading your default_registry.json and sending that data directly, or using a proper NBT library.